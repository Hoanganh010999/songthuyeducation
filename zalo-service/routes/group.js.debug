const express = require('express');
const router = express.Router();
const { verifyApiKey } = require('../middleware/auth');
const { getZaloClient } = require('../services/zaloClient');

/**
 * GET /api/group/list
 * Get all groups for specific account
 */
router.get('/list', verifyApiKey, async (req, res) => {
  try {
    console.log('üìã [GET /api/group/list] Getting groups list...');

    // üî• FIX: Get account ID from header or query
    const accountId = req.headers['x-account-id'] || req.query.account_id;

    if (!accountId) {
      console.error('   ‚ùå No account_id provided');
      return res.status(400).json({
        success: false,
        message: 'account_id is required (header X-Account-Id or query param)'
      });
    }

    console.log('   Account ID:', accountId);

    // üî• FIX: Get session for specific account
    const { getSession } = require('../services/zaloClient');
    const zalo = getSession(parseInt(accountId));

    if (!zalo) {
      console.error('   ‚ùå Zalo session not found for account:', accountId);
      return res.status(400).json({
        success: false,
        message: `Zalo session not found for account ${accountId}. Please login first.`
      });
    }

    console.log('   ‚úÖ Zalo session found');
    console.log('   Available methods:', Object.getOwnPropertyNames(zalo)
      .filter(name => typeof zalo[name] === 'function')
      .sort()
      .join(', '));

    let groups = null;

    // Try different method names
    const methodNames = ['getAllGroups', 'getGroups', 'listGroups', 'getGroupList'];
    let methodFound = false;

    for (const methodName of methodNames) {
      if (typeof zalo[methodName] === 'function') {
        console.log(`   ‚úÖ Found method: ${methodName}()`);
        methodFound = true;
        try {
          groups = await zalo[methodName]();
          console.log(`   ‚úÖ ${methodName}() success!`);
          break;
        } catch (error) {
          console.error(`   ‚ùå ${methodName}() error:`, error.message);
          // Try next method
          continue;
        }
      }
    }
    
    if (!methodFound) {
      console.error('‚ùå No groups method found!');
      console.log('   Please check zalo-api-final documentation for correct method name');
      
      return res.status(500).json({
        success: false,
        message: 'Groups method not available. Available methods: ' + 
          Object.getOwnPropertyNames(zalo)
            .filter(name => typeof zalo[name] === 'function')
            .sort()
            .join(', ')
      });
    }
    
    if (!groups) {
      return res.status(500).json({
        success: false,
        message: 'Failed to retrieve groups - all methods failed'
      });
    }
    
    console.log('‚úÖ getAllGroups() called successfully');
    console.log('   Response type:', typeof groups);
    console.log('   Is array:', Array.isArray(groups));
    console.log('   Response keys:', groups && typeof groups === 'object' ? Object.keys(groups).join(', ') : 'N/A');
    
    // Handle different response formats
    let groupsList = [];
    
    if (Array.isArray(groups)) {
      groupsList = groups;
      console.log('   ‚úÖ Response is array, using directly');
    } else if (groups && typeof groups === 'object') {
      // Check if response has gridVerMap (Zalo API format)
      if (groups.gridVerMap && typeof groups.gridVerMap === 'object') {
        console.log('   ‚úÖ Found gridVerMap with', Object.keys(groups.gridVerMap).length, 'group IDs');
        console.log('   Fetching group details for each ID...');
        
        // Extract group IDs from gridVerMap
        const groupIds = Object.keys(groups.gridVerMap);
        
        // Fetch group info for each ID (limit to first 50 to avoid timeout)
        const maxGroups = Math.min(groupIds.length, 50);
        console.log(`   Fetching details for ${maxGroups} groups (out of ${groupIds.length} total)...`);
        
        for (let i = 0; i < maxGroups; i++) {
          const groupId = groupIds[i];
          try {
            const groupInfo = await zalo.getGroupInfo(groupId);
            if (groupInfo) {
              groupsList.push({
                id: groupId,
                version: groups.gridVerMap[groupId],
                ...groupInfo
              });
            }
          } catch (error) {
            console.log(`   ‚ö†Ô∏è  Failed to get info for group ${groupId}:`, error.message);
            // Add basic info even if getGroupInfo fails
            groupsList.push({
              id: groupId,
              version: groups.gridVerMap[groupId],
              name: `Group ${groupId}`,
              error: error.message
            });
          }
          
          // Small delay to avoid rate limiting
          if (i < maxGroups - 1) {
            await new Promise(resolve => setTimeout(resolve, 100));
          }
        }
        
        console.log(`   ‚úÖ Fetched ${groupsList.length} group details`);
      } else if (groups.data && Array.isArray(groups.data)) {
        groupsList = groups.data;
        console.log('   ‚úÖ Found groups.data array');
      } else if (groups.groups && Array.isArray(groups.groups)) {
        groupsList = groups.groups;
        console.log('   ‚úÖ Found groups.groups array');
      } else if (groups.list && Array.isArray(groups.list)) {
        groupsList = groups.list;
        console.log('   ‚úÖ Found groups.list array');
      } else if (groups.result && Array.isArray(groups.result)) {
        groupsList = groups.result;
        console.log('   ‚úÖ Found groups.result array');
      } else {
        // Try to extract array from object values
        const values = Object.values(groups);
        const arrayValue = values.find(v => Array.isArray(v));
        if (arrayValue) {
          groupsList = arrayValue;
          console.log('   ‚úÖ Found array in object values');
        } else {
          console.log('   ‚ö†Ô∏è  No array found in response object');
          console.log('   Object structure:', Object.keys(groups));
        }
      }
    }
    
    console.log('‚úÖ Groups list extracted:', groupsList.length, 'groups');
    if (groupsList.length > 0) {
      console.log('   First group sample:', JSON.stringify(groupsList[0], null, 2).substring(0, 500));
    } else {
      console.log('   ‚ö†Ô∏è  No groups found - this might be normal if account has no groups');
    }
    
    // Normalize group data structure
    const normalizedGroups = await Promise.all(groupsList.map(async (group) => {
      // Extract from gridInfoMap if available (Zalo API format)
      let groupInfo = null;
      if (group.gridInfoMap && typeof group.gridInfoMap === 'object') {
        const groupId = group.id || Object.keys(group.gridInfoMap)[0];
        groupInfo = group.gridInfoMap[groupId];
      }
      
      const groupId = group.id || group.groupId || group._id || group.gid || group.group_id || groupInfo?.groupId;
      
      // Calculate members count - try multiple sources
      let membersCount = 0;
      if (groupInfo?.memberIds && Array.isArray(groupInfo.memberIds)) {
        membersCount = groupInfo.memberIds.length;
      } else if (group.memberIds && Array.isArray(group.memberIds)) {
        membersCount = group.memberIds.length;
      } else if (groupInfo?.totalMember && typeof groupInfo.totalMember === 'number' && groupInfo.totalMember > 0) {
        // Use totalMember from gridInfoMap if memberIds is empty
        membersCount = groupInfo.totalMember;
      } else if (groupInfo?.memVerList && Array.isArray(groupInfo.memVerList)) {
        // Count unique member IDs from memVerList (format: "userId_version")
        const uniqueMembers = new Set();
        groupInfo.memVerList.forEach(memVer => {
          if (typeof memVer === 'string') {
            const parts = memVer.split('_');
            if (parts[0]) {
              uniqueMembers.add(parts[0]);
            }
          }
        });
        membersCount = uniqueMembers.size;
      } else if (groupInfo?.memberCount) {
        membersCount = groupInfo.memberCount;
      } else if (group.members_count) {
        membersCount = group.members_count;
      } else if (group.memberCount) {
        membersCount = group.memberCount;
      }
      
      // If still 0, try to fetch members directly (with timeout to avoid blocking)
      if (membersCount === 0 && groupId && typeof zalo.getGroupMembersInfo === 'function') {
        try {
          // Use Promise.race to timeout after 3 seconds
          const membersPromise = zalo.getGroupMembersInfo(groupId);
          const timeoutPromise = new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Timeout')), 3000)
          );
          
          const membersData = await Promise.race([membersPromise, timeoutPromise]);
          
          // Extract members array
          let members = [];
          if (Array.isArray(membersData)) {
            members = membersData;
          } else if (membersData && Array.isArray(membersData.members)) {
            members = membersData.members;
          } else if (membersData && membersData.profiles) {
            // Extract from profiles (Zalo format)
            if (Array.isArray(membersData.profiles)) {
              members = membersData.profiles;
            } else if (typeof membersData.profiles === 'object') {
              members = Object.values(membersData.profiles);
            }
          } else if (membersData && membersData.gridInfoMap) {
            members = Object.values(membersData.gridInfoMap);
          }
          
          if (members.length > 0) {
            membersCount = members.length;
            console.log(`   ‚úÖ Fetched members for group ${groupId}: ${membersCount} members`);
          }
        } catch (error) {
          console.log(`   ‚ö†Ô∏è  Could not fetch members for group ${groupId}:`, error.message);
          // Keep membersCount as 0 if fetch fails
        }
      }
      
      // Try to extract common fields
      const normalized = {
        id: groupId,
        name: groupInfo?.name || group.name || group.groupName || group.title || group.group_name || `Group ${groupId}`,
        avatar: groupInfo?.avt || groupInfo?.fullAvt || group.avatar || group.avatarUrl || group.image || group.avatar_url || '',
        description: groupInfo?.desc || group.description || group.desc || '',
        members_count: membersCount,
        admin_ids: groupInfo?.adminIds || group.adminIds || [],
        creator_id: groupInfo?.creatorId || group.creatorId || group.creator_id,
        type: groupInfo?.type || group.type,
        version: group.version || groupInfo?.version,
        // Keep all original data for debugging
        ...group
      };
      
      return normalized;
    }));
    
    // Log first group for debugging
    if (normalizedGroups.length > 0) {
      console.log('   üìä Sample normalized group:', {
        id: normalizedGroups[0].id,
        name: normalizedGroups[0].name,
        members_count: normalizedGroups[0].members_count,
        has_gridInfoMap: !!groupsList[0]?.gridInfoMap
      });
    }
    
    res.json({
      success: true,
      data: normalizedGroups,
      count: normalizedGroups.length
    });
  } catch (error) {
    console.error('‚ùå Get groups error:', error);
    console.error('   Error message:', error.message);
    if (error.stack) {
      console.error('   Stack:', error.stack);
    }
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to get groups'
    });
  }
});

/**
 * GET /api/group/info/:groupId
 * Get group information
 */
router.get('/info/:groupId', verifyApiKey, async (req, res) => {
  try {
    const { groupId } = req.params;

    console.log('üìã [GET /api/group/info/:groupId] Getting group info...');
    console.log('   Group ID:', groupId);

    // üî• FIX: Get account ID from header or query (same as /list endpoint)
    const accountId = req.headers['x-account-id'] || req.query.accountId || req.query.account_id;

    if (!accountId) {
      console.error('   ‚ùå No account_id provided');
      return res.status(400).json({
        success: false,
        message: 'account_id is required (header X-Account-Id or query param)'
      });
    }

    console.log('   Account ID:', accountId);

    // üî• FIX: Get session for specific account
    const { getSession } = require('../services/zaloClient');
    const zalo = getSession(parseInt(accountId));

    if (!zalo) {
      console.error('   ‚ùå Zalo session not found for account:', accountId);
      return res.status(400).json({
        success: false,
        message: `Zalo session not found for account ${accountId}. Please login first.`
      });
    }

    console.log('   ‚úÖ Zalo session found');
    console.log('   Calling getGroupInfo()...');

    const groupInfoRaw = await zalo.getGroupInfo(groupId);

    console.log('   ‚úÖ getGroupInfo() success!');
    console.log('   Raw response type:', typeof groupInfoRaw);
    console.log('   Raw response keys:', groupInfoRaw ? Object.keys(groupInfoRaw) : 'null');

    // Extract group info from gridInfoMap if needed
    let groupInfo = null;
    if (groupInfoRaw && groupInfoRaw.gridInfoMap) {
      // gridInfoMap format: { [groupId]: {...groupInfo} }
      const gridInfoValues = Object.values(groupInfoRaw.gridInfoMap);
      if (gridInfoValues.length > 0) {
        groupInfo = gridInfoValues[0];
        console.log('   ‚úÖ Extracted group info from gridInfoMap');
      }
    } else {
      groupInfo = groupInfoRaw;
    }

    if (!groupInfo) {
      console.error('   ‚ùå No group info found');
      return res.status(404).json({
        success: false,
        message: 'Group not found'
      });
    }

    console.log('   Group info keys:', Object.keys(groupInfo));

    // Normalize group data structure
    const normalized = {
      id: groupId,
      name: groupInfo.name || groupInfo.groupName || 'Unknown Group',
      avatar: groupInfo.avt || groupInfo.fullAvt || groupInfo.avatar || groupInfo.avatarUrl || null,
      avatar_url: groupInfo.avt || groupInfo.fullAvt || groupInfo.avatar || groupInfo.avatarUrl || null,
      description: groupInfo.desc || groupInfo.description || '',
      type: groupInfo.type || 0,
      creator_id: groupInfo.creatorId || null,
      admin_ids: groupInfo.adminIds || [],
      members_count: groupInfo.totalMember || (groupInfo.memberIds ? groupInfo.memberIds.length : 0),
      // Keep all original data
      ...groupInfo
    };

    console.log('   ‚úÖ Normalized group:', {
      id: normalized.id,
      name: normalized.name,
      has_avatar: !!normalized.avatar
    });

    res.json({
      success: true,
      data: normalized
    });
  } catch (error) {
    console.error('Get group info error:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to get group info'
    });
  }
});

/**
 * GET /api/group/members/:groupId
 * Get group members
 */
router.get('/members/:groupId', verifyApiKey, async (req, res) => {
  try {
    const { groupId } = req.params;

    console.log('üìã Getting members for group:', groupId);

    // üî• FIX: Get account ID from header or query
    const accountId = req.headers['x-account-id'] || req.query.accountId || req.query.account_id;

    if (!accountId) {
      console.error('   ‚ùå No account_id provided');
      return res.status(400).json({
        success: false,
        message: 'account_id is required (header X-Account-Id or query param)'
      });
    }

    console.log('   Account ID:', accountId);

    // üî• FIX: Get session for specific account
    const { getSession } = require('../services/zaloClient');
    const zalo = getSession(parseInt(accountId));

    if (!zalo) {
      console.error('   ‚ùå Zalo session not found for account:', accountId);
      return res.status(400).json({
        success: false,
        message: `Zalo session not found for account ${accountId}. Please login first.`
      });
    }

    console.log('   ‚úÖ Zalo session found');
    
    // Check available methods
    const hasGetGroupMembersInfo = typeof zalo.getGroupMembersInfo === 'function';
    const hasGetGroupInfo = typeof zalo.getGroupInfo === 'function';
    
    console.log('   Available methods:', {
      getGroupMembersInfo: hasGetGroupMembersInfo,
      getGroupInfo: hasGetGroupInfo,
    });
    
    let members = [];
    
    // Try getGroupMembersInfo first
    if (hasGetGroupMembersInfo) {
      try {
        console.log('   Trying getGroupMembersInfo()...');
        const membersData = await zalo.getGroupMembersInfo(groupId);
        console.log('   ‚úÖ getGroupMembersInfo() success!');
        console.log('   Raw response type:', typeof membersData);
        console.log('   Raw response keys:', membersData ? Object.keys(membersData) : 'null');
        
        // Debug: log profiles structure
        if (membersData && membersData.profiles) {
          console.log('   Profiles type:', typeof membersData.profiles);
          console.log('   Profiles is array?', Array.isArray(membersData.profiles));
          if (typeof membersData.profiles === 'object' && !Array.isArray(membersData.profiles)) {
            console.log('   Profiles keys:', Object.keys(membersData.profiles));
            const profileValues = Object.values(membersData.profiles);
            console.log('   Profiles values count:', profileValues.length);
            if (profileValues.length > 0) {
              console.log('   First profile value sample:', JSON.stringify(profileValues[0], null, 2));
            }
          }
        }
        
        // Extract members array from response
        if (Array.isArray(membersData)) {
          members = membersData;
        } else if (membersData && Array.isArray(membersData.members)) {
          members = membersData.members;
        } else if (membersData && Array.isArray(membersData.data)) {
          members = membersData.data;
        } else if (membersData && membersData.profiles) {
          // Extract from profiles (Zalo format from getGroupMembersInfo)
          if (Array.isArray(membersData.profiles)) {
            members = membersData.profiles;
          } else if (typeof membersData.profiles === 'object') {
            members = Object.values(membersData.profiles);
          }
        } else if (membersData && membersData.gridInfoMap) {
          // Extract from gridInfoMap (Zalo format)
          members = Object.values(membersData.gridInfoMap);
        }
        
        console.log('   Members extracted from getGroupMembersInfo:', members.length);
        if (members.length > 0) {
          console.log('   First member sample:', JSON.stringify(members[0], null, 2));
        }
      } catch (error) {
        console.error('   ‚ùå getGroupMembersInfo() error:', error.message);
        // Continue to fallback
      }
    }
    
    // Fallback: try getGroupInfo to extract member IDs
    if (members.length === 0 && hasGetGroupInfo) {
      try {
        console.log('   Trying getGroupInfo() as fallback...');
        const groupInfo = await zalo.getGroupInfo(groupId);
        console.log('   ‚úÖ getGroupInfo() success!');
        console.log('   Group info keys:', groupInfo ? Object.keys(groupInfo) : 'null');
        
        // Extract member IDs from memVerList and create basic member objects
        if (groupInfo && groupInfo.gridInfoMap) {
          const gridInfoValues = Object.values(groupInfo.gridInfoMap);
          console.log('   GridInfoMap values count:', gridInfoValues.length);
          
          // Check if gridInfoMap contains group info (has groupId) or member info
          if (gridInfoValues.length > 0) {
            const firstValue = gridInfoValues[0];
            console.log('   First gridInfoMap value has groupId?', !!firstValue.groupId);
            console.log('   First gridInfoMap value keys:', Object.keys(firstValue));
            
            // If first value has groupId, it's group info, extract member IDs from memVerList
            if (firstValue.groupId && firstValue.memVerList) {
              console.log('   Extracting member IDs from memVerList:', firstValue.memVerList.length);
              
              // Parse memVerList (format: "uid_version")
              members = firstValue.memVerList.map(memVer => {
                const [uid, version] = memVer.split('_');
                return {
                  id: uid,
                  uid: uid,
                  version: version,
                  // We only have ID, no other info yet
                  displayName: null,
                  avatar: null,
                  type: firstValue.adminIds?.includes(uid) ? 1 : 0,
                };
              });
              
              console.log('   Created', members.length, 'member objects from memVerList');
            } else {
              // gridInfoMap contains actual member info
              members = gridInfoValues;
            }
          }
        }
        
        console.log('   Members from groupInfo:', members.length);
        if (members.length > 0) {
          console.log('   First member from groupInfo:', JSON.stringify(members[0], null, 2));
        }
      } catch (error) {
        console.error('   ‚ùå getGroupInfo() error:', error.message);
      }
    }
    
    // If members only have IDs (no displayName), fetch user info
    const membersNeedInfo = members.filter(m => !m.displayName && !m.name);
    console.log(`   üîç Members needing info: ${membersNeedInfo.length}/${members.length}`);
    console.log(`   üîç getUserInfo available: ${typeof zalo.getUserInfo === 'function'}`);
    
    if (membersNeedInfo.length > 0 && typeof zalo.getUserInfo === 'function') {
      console.log(`   üì• Fetching user info for ${membersNeedInfo.length} members...`);
      
      try {
        // Fetch user info in batches (max 10 at a time to avoid timeout)
        const batchSize = 10;
        for (let i = 0; i < membersNeedInfo.length; i += batchSize) {
          const batch = membersNeedInfo.slice(i, i + batchSize);
          
          await Promise.all(batch.map(async (member) => {
            try {
              console.log(`   üîÑ Calling getUserInfo for: ${member.id || member.uid}`);
              const userInfo = await zalo.getUserInfo(member.id || member.uid);
              
              // Log raw response to debug structure
              console.log(`   üì¶ getUserInfo response for ${member.id}:`, {
                type: typeof userInfo,
                isNull: userInfo === null,
                isUndefined: userInfo === undefined,
                keys: userInfo ? Object.keys(userInfo) : 'no keys',
                sample: userInfo ? JSON.stringify(userInfo).substring(0, 200) : 'null',
              });
              
              if (userInfo) {
                // Extract user data from changed_profiles
                const userId = member.id || member.uid;
                let userData = null;
                
                // getUserInfo returns: { changed_profiles: { [userId]: {...} } }
                if (userInfo.changed_profiles && userInfo.changed_profiles[userId]) {
                  userData = userInfo.changed_profiles[userId];
                } else if (userInfo.displayName) {
                  // Fallback: direct access (in case structure is different)
                  userData = userInfo;
                }
                
                if (userData) {
                  member.displayName = userData.displayName || userData.zaloName || userData.name || null;
                  member.avatar = userData.avatar || userData.avatarUrl || userData.avatar_url || null;
                  member.phone = userData.phoneNumber || userData.phone || null;
                  
                  console.log(`   ‚úÖ Fetched info for ${member.id}: ${member.displayName}`);
                } else {
                  console.log(`   ‚ö†Ô∏è  No user data found in changed_profiles for ${member.id}`);
                }
              } else {
                console.log(`   ‚ö†Ô∏è  getUserInfo returned null/undefined for ${member.id}`);
              }
            } catch (err) {
              console.error(`   ‚ö†Ô∏è  Failed to fetch info for ${member.id}:`, err.message);
              // Keep member with ID only
            }
          }));
        }
        
        console.log('   ‚úÖ User info fetching completed');
      } catch (error) {
        console.error('   ‚ö†Ô∏è  Error fetching user info:', error.message);
        // Continue with members as-is
      }
    }
    
    // Normalize member data structure
    const normalizedMembers = members.map(member => {
      return {
        id: member.id || member.uid || member.userId || member.zalo_user_id,
        display_name: member.displayName || member.name || member.display_name || `User ${(member.id || member.uid || '').slice(-4)}`,
        avatar_url: member.avatar || member.avatarUrl || member.avatar_url || null,
        is_admin: member.type === 1 || member.isAdmin || member.is_admin || false,
        phone: member.phone || null,
        // Keep original data for reference
        ...member
      };
    });
    
    console.log('   ‚úÖ Returning', normalizedMembers.length, 'normalized members');
    
    res.json({
      success: true,
      data: normalizedMembers,
      count: normalizedMembers?.length || 0
    });
  } catch (error) {
    console.error('Get group members error:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to get group members'
    });
  }
});

/**
 * POST /api/group/create
 * Create a new group
 */
router.post('/create', verifyApiKey, async (req, res) => {
  try {
    console.log('üìã [POST /api/group/create] Creating new group...');
    console.log('   Request body:', JSON.stringify(req.body));
    
    const { name, members, avatarPath, accountId } = req.body;
    
    if (!members || !Array.isArray(members) || members.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'members array is required and must not be empty'
      });
    }
    
    const zalo = getZaloClient();
    if (!zalo) {
      return res.status(400).json({
        success: false,
        message: 'Zalo client not initialized'
      });
    }
    
    // Check if createGroup method exists
    if (typeof zalo.createGroup !== 'function') {
      console.error('   ‚ùå createGroup method not found');
      return res.status(500).json({
        success: false,
        message: 'createGroup method not available in zalo client'
      });
    }
    
    console.log('   ‚úÖ Calling createGroup()...');
    console.log('   Options:', { name, members: members.length, hasAvatar: !!avatarPath });
    
    const options = {
      members: members.map(id => String(id)), // Ensure all IDs are strings
    };
    
    if (name) {
      options.name = name;
    }
    
    if (avatarPath) {
      options.avatarSource = avatarPath;
    }
    
    const result = await zalo.createGroup(options);
    
    console.log('   ‚úÖ Group created successfully');
    console.log('   Result:', JSON.stringify(result));
    
    res.json({
      success: true,
      message: 'Group created successfully',
      data: {
        groupId: result.groupId,
        groupType: result.groupType,
        successMembers: result.sucessMembers || result.successMembers || [],
        errorMembers: result.errorMembers || [],
        error_data: result.error_data || {},
      }
    });
  } catch (error) {
    console.error('‚ùå Create group error:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to create group',
      error: process.env.NODE_ENV === 'development' ? error.stack : undefined,
    });
  }
});

/**
 * POST /api/group/add-members/:groupId
 * Add members to an existing group
 */
router.post('/add-members/:groupId', verifyApiKey, async (req, res) => {
  try {
    const { groupId } = req.params;
    const { memberIds } = req.body;
    
    console.log('üìã [POST /api/group/add-members] Adding members to group...');
    console.log('   Group ID:', groupId);
    console.log('   Member IDs:', memberIds);
    
    if (!memberIds || (Array.isArray(memberIds) && memberIds.length === 0) || (!Array.isArray(memberIds) && !memberIds)) {
      return res.status(400).json({
        success: false,
        message: 'memberIds is required (string or array of strings)'
      });
    }
    
    const zalo = getZaloClient();
    if (!zalo) {
      return res.status(400).json({
        success: false,
        message: 'Zalo client not initialized'
      });
    }
    
    // Check if addUserToGroup method exists
    if (typeof zalo.addUserToGroup !== 'function') {
      console.error('   ‚ùå addUserToGroup method not found');
      return res.status(500).json({
        success: false,
        message: 'addUserToGroup method not available in zalo client'
      });
    }
    
    console.log('   ‚úÖ Calling addUserToGroup()...');
    
    // Ensure memberIds are strings
    const normalizedMemberIds = Array.isArray(memberIds) 
      ? memberIds.map(id => String(id))
      : String(memberIds);
    
    const result = await zalo.addUserToGroup(normalizedMemberIds, String(groupId));
    
    console.log('   ‚úÖ Members added successfully');
    console.log('   Result:', JSON.stringify(result));
    
    // Calculate success count
    const requestedCount = Array.isArray(normalizedMemberIds) ? normalizedMemberIds.length : 1;
    const errorCount = result.errorMembers ? result.errorMembers.length : 0;
    const successCount = requestedCount - errorCount;
    
    res.json({
      success: true,
      message: `Successfully added ${successCount} member(s) to group`,
      data: {
        groupId: groupId,
        requestedCount: requestedCount,
        successCount: successCount,
        errorMembers: result.errorMembers || [],
        error_data: result.error_data || {},
      }
    });
  } catch (error) {
    console.error('‚ùå Add members to group error:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to add members to group',
      error: process.env.NODE_ENV === 'development' ? error.stack : undefined,
    });
  }
});

/**
 * POST /api/group/change-avatar/:groupId
 * Change group avatar
 */
router.post('/change-avatar/:groupId', verifyApiKey, async (req, res) => {
  try {
    console.log('üìã [POST /api/group/change-avatar/:groupId] Changing group avatar...');
    console.log('   Request body:', JSON.stringify(req.body));
    
    const { groupId } = req.params;
    const { avatarPath } = req.body; // avatarPath can be file path or URL
    
    if (!groupId || !avatarPath) {
      return res.status(400).json({
        success: false,
        message: 'groupId and avatarPath are required'
      });
    }
    
    const zalo = getZaloClient();
    if (!zalo) {
      return res.status(400).json({
        success: false,
        message: 'Zalo client not initialized'
      });
    }
    
    // Check if changeGroupAvatar method exists
    if (typeof zalo.changeGroupAvatar !== 'function') {
      console.error('   ‚ùå changeGroupAvatar method not found');
      return res.status(500).json({
        success: false,
        message: 'changeGroupAvatar method not available in zalo client'
      });
    }
    
    console.log('   ‚úÖ Calling changeGroupAvatar()...');
    const result = await zalo.changeGroupAvatar(avatarPath, String(groupId));
    
    console.log('   ‚úÖ Group avatar changed successfully');
    console.log('   Result:', JSON.stringify(result));
    
    res.json({
      success: true,
      message: 'Group avatar changed successfully',
      data: result,
    });
  } catch (error) {
    console.error('‚ùå Change group avatar error:', error);
    res.status(500).json({
      success: false,
      message: error.message || 'Failed to change group avatar',
      error: process.env.NODE_ENV === 'development' ? error.stack : undefined,
    });
  }
});

module.exports = router;

