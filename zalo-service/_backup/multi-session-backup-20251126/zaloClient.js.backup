/**
 * ZALO CLIENT - MULTI-SESSION ARCHITECTURE
 *
 * Supports multiple Zalo accounts connected simultaneously
 * Each account has its own session stored in a Map
 *
 * Architecture:
 * - sessions: Map<accountId, Zalo API instance>
 * - activeAccountId: Currently active account ID
 * - sessionData: Map<accountId, {isInitialized, loginCompleted, wsListener, keepAliveInterval}>
 */

const { Zalo } = require('zalo-api-final');
const fs = require('fs');
const path = require('path');
const http = require('http');
const HealthMonitor = require('./health-monitor');

// ============================================================================
// MULTI-SESSION STATE
// ============================================================================

/**
 * Map of all active sessions
 * Key: accountId (number)
 * Value: Zalo API instance
 */
const sessions = new Map();

/**
 * Map of session metadata
 * Key: accountId (number)
 * Value: { isInitialized, loginCompleted, loginInProgress, wsListener, keepAliveInterval }
 */
const sessionData = new Map();
/**
 * Map to lookup zalo_id from account_id (for session sharing across branches)
 * Key: accountId (number)
 * Value: zaloId (string like "688678230773032494")
 */
const accountToZaloId = new Map();

/**
 * Map of health monitors
 * Key: accountId (number)
 * Value: HealthMonitor instance
 */
const healthMonitors = new Map();

/**
 * Currently active account ID
 * API calls without explicit accountId will use this account
 */
let activeAccountId = null;

/**
 * Default keep-alive interval (45 seconds)
 */
const KEEP_ALIVE_INTERVAL = 45000;

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Get session for a specific account
 * If no accountId provided, use activeAccountId
 * Supports session sharing: tries direct lookup first, then by zalo_id
 */
function getSession(accountId = null) {
  const targetId = accountId || activeAccountId;

  if (!targetId) {
    console.log('‚ö†Ô∏è  No accountId provided and no active account set');
    return null;
  }

  console.log(`\nüîç [getSession] Looking up session for account ${targetId}...`);
  console.log(`   üìä Current state:`, {
    totalSessions: sessions.size,
    totalMappings: accountToZaloId.size,
    sessionsKeys: Array.from(sessions.keys()),
    mappingsKeys: Array.from(accountToZaloId.keys()),
  });

  // STEP 1: Try direct lookup by accountId (backward compatibility)
  if (sessions.has(targetId)) {
    const session = sessions.get(targetId);
    console.log(`   ‚úÖ STEP 1: Found session via direct accountId lookup (${targetId})`);
    console.log(`   üì¶ Session object:`, {
      hasSession: !!session,
      hasSendMessage: typeof session?.sendMessage === 'function',
      hasListener: !!session?.listener,
      sessionType: session?.constructor?.name,
    });
    return session;
  }

  // STEP 2: Try lookup by zalo_id (for session sharing across branches)
  const zaloId = accountToZaloId.get(targetId);
  console.log(`   üîç STEP 2: Looking for zalo_id mapping...`, {
    accountId: targetId,
    zaloId: zaloId,
    hasMappingInMap: accountToZaloId.has(targetId),
  });

  if (zaloId && sessions.has(zaloId)) {
    const session = sessions.get(zaloId);
    console.log(`   ‚úÖ STEP 2: Found session via zalo_id lookup (zalo_id: ${zaloId})`);
    console.log(`   üì¶ Session object:`, {
      hasSession: !!session,
      hasSendMessage: typeof session?.sendMessage === 'function',
      hasListener: !!session?.listener,
      sessionType: session?.constructor?.name,
    });
    console.log(`   üîó [Session Sharing] Account ${targetId} ‚Üí zalo_id ${zaloId} ‚Üí shared session`);
    return session;
  }

  console.log(`   ‚ùå No session found for account ID: ${targetId}`);
  console.log(`   üí° Troubleshooting info:`, {
    directLookupFailed: !sessions.has(targetId),
    hasZaloIdMapping: !!zaloId,
    zaloIdLookupFailed: zaloId ? !sessions.has(zaloId) : 'N/A (no zaloId)',
  });
  return null;
}

/**
 * Get session data (metadata) for an account
 */
function getSessionData(accountId) {
  if (!sessionData.has(accountId)) {
    // Initialize default data
    sessionData.set(accountId, {
      isInitialized: false,
      loginCompleted: false,
      loginInProgress: false,
      wsListener: null,
      keepAliveInterval: null,
      isRestarting: false,
      restartTimeout: null
    });
  }
  return sessionData.get(accountId);
}

/**
 * Update session data
 */
function updateSessionData(accountId, updates) {
  const data = getSessionData(accountId);
  Object.assign(data, updates);
  sessionData.set(accountId, data);
}

/**
 * Generate session ID for storage
 */
function getSessionId(accountId) {
  return `zalo_${accountId}`;
}

/**
 * Get sessions directory path
 */
function getSessionsDir() {
  return path.join(__dirname, '..', 'sessions');
}

/**
 * Ensure sessions directory exists
 */
function ensureSessionsDir() {
  const sessionsDir = getSessionsDir();
  if (!fs.existsSync(sessionsDir)) {
    fs.mkdirSync(sessionsDir, { recursive: true });
    console.log('üìÅ Created sessions directory:', sessionsDir);
  }
  return sessionsDir;
}

// ============================================================================
// INITIALIZATION
// ============================================================================

/**
 * Initialize Zalo API client with QR Code login
 *
 * @param {number} accountId - Account ID to initialize
 * @param {function} qrCallback - Callback for QR code
 * @param {boolean} forceNew - Force new login even if session exists
 * @returns {Promise<Zalo>} Zalo API instance
 */
async function initializeZalo(accountId, qrCallback, forceNew = false) {
  try {
    console.log(`üîß [Multi-Session] Initializing account ID: ${accountId}`);
    console.log(`   forceNew: ${forceNew}`);
    console.log(`   Total sessions: ${sessions.size}`);
    console.log(`   Active sessions: ${Array.from(sessions.keys()).join(', ')}`);

    const data = getSessionData(accountId);
    const existingSession = sessions.get(accountId);

    // If already initialized and login completed, return existing instance
    if (!forceNew && data.isInitialized && data.loginCompleted && existingSession) {
      console.log(`‚úÖ Using existing session for account ${accountId}`);

      // Verify it's an API instance
      if (typeof existingSession.getAllFriends === 'function') {
        if (qrCallback && typeof qrCallback === 'function') {
          console.log('‚ö†Ô∏è  Already logged in, cannot generate new QR code');
          console.log('   Use forceNew=true to create new session');
        }
        return existingSession;
      } else {
        console.log('‚ö†Ô∏è  Existing session is not valid API instance, reinitializing...');
        updateSessionData(accountId, {
          isInitialized: false,
          loginCompleted: false
        });
        sessions.delete(accountId);
      }
    }

    // If forceNew, reset state for this account only
    if (forceNew) {
      console.log(`üîÑ Force new login for account ${accountId}, resetting state...`);
      updateSessionData(accountId, {
        isInitialized: false,
        loginCompleted: false,
        loginInProgress: false
      });

      // Note: We DON'T clear other sessions or activeAccountId
      // Only this specific account is reset
    }

    console.log(`üîß Creating new Zalo client for account ${accountId}...`);

    // Create new Zalo instance
    const zaloClient = new Zalo({
      cookie: '', // Will be set via QR login
      imei: process.env.ZALO_IMEI || '',
      userAgent: process.env.ZALO_USER_AGENT || '',
      selfListen: true, // Enable receiving messages from other devices
    });
    console.log(`   ‚úÖ selfListen enabled for account ${accountId}`);

    // QR login process
    console.log(`üîê Initiating QR Code login for account ${accountId}...`);

    updateSessionData(accountId, {
      loginInProgress: true,
      loginCompleted: false
    });

    const qrFilePath = path.join(__dirname, '..', `qr_${accountId}.png`);

    // Clean up old QR file if exists
    try {
      if (fs.existsSync(qrFilePath)) {
        fs.unlinkSync(qrFilePath);
        console.log(`üßπ Cleaned up old QR file for account ${accountId}`);
      }
    } catch (error) {
      console.log(`‚ö†Ô∏è  Could not delete old QR file: ${error.message}`);
    }

    let qrCodeString = null;
    let qrReceived = false;
    let qrBase64 = null;

    console.log(`üìû Starting loginQR with callback for account ${accountId}...`);

    // loginQR() returns Promise<API> - the API instance
    const loginPromise = zaloClient.loginQR((qr) => {
      console.log(`üì± QR Code callback received for account ${accountId}!`);
      console.log('   QR type:', typeof qr);
      console.log('   QR length:', qr ? qr.length : 0);

      qrCodeString = qr;
      qrReceived = true;

      // Convert QR string to base64 image data URL
      if (qr && qr.startsWith('data:')) {
        qrBase64 = qr;
      } else if (qr) {
        qrBase64 = `data:image/png;base64,${qr}`;
      }

      // Call custom callback if provided
      if (qrCallback && typeof qrCallback === 'function') {
        console.log(`üì§ Calling custom QR callback for account ${accountId}...`);
        qrCallback(qrBase64);
      }
    });

    // Handle login completion
    loginPromise.then(async (apiInstance) => {
      console.log(`\n‚úÖ‚úÖ‚úÖ QR login successful for account ${accountId}!`);
      console.log('   Received API instance');

      // IMPORTANT: Store API instance in sessions Map
      sessions.set(accountId, apiInstance);
      console.log(`   ‚úÖ Stored session for account ${accountId} in Map`);
      console.log(`   Total sessions now: ${sessions.size}`);

      // Declare zaloId at function scope so it's accessible throughout
      let zaloId = null;

      // SESSION SHARING: Fetch zalo_id and store session by zalo_id for multi-branch support
      try {
        console.log(`üîó [Session Sharing] Fetching zalo_id for account ${accountId}...`);

        const laravelUrl = process.env.LARAVEL_URL || "http://127.0.0.1:8000";
        const fetchUrl = `${laravelUrl}/api/zalo/accounts/${accountId}/zalo-id`;

        // Fetch zalo_id from Laravel
        const zaloIdData = await new Promise((resolve, reject) => {
          http.get(fetchUrl, (resp) => {
            let data = "";
            resp.on("data", (chunk) => { data += chunk; });
            resp.on("end", () => {
              try {
                resolve(JSON.parse(data));
              } catch (e) {
                reject(e);
              }
            });
          }).on("error", reject);
        });

        if (zaloIdData.success && zaloIdData.data && zaloIdData.data.zalo_id) {
          zaloId = zaloIdData.data.zalo_id;
          console.log(`   ‚úÖ Got zalo_id: ${zaloId}`);

          // Store session by zalo_id (primary key for session sharing)
          sessions.set(zaloId, apiInstance);
          console.log(`   ‚úÖ Stored session with zalo_id: ${zaloId}`);

          // Store mapping accountId ‚Üí zaloId
          accountToZaloId.set(accountId, zaloId);
          console.log(`   ‚úÖ Created mapping: account ${accountId} ‚Üí zalo_id ${zaloId}`);
        } else {
          console.log(`   ‚ö†Ô∏è  Could not fetch zalo_id, session sharing disabled for this account`);
        }
      } catch (error) {
        console.error(`   ‚ö†Ô∏è  Session sharing setup failed: ${error.message}`);
        // Non-critical error - session still works via accountId
      }

      updateSessionData(accountId, {
        isInitialized: true,
        loginCompleted: true,
        loginInProgress: false
      });

      // Set as active if no active account
      if (!activeAccountId) {
        activeAccountId = accountId;
        console.log(`   ‚úÖ Set account ${accountId} as active (first account)`);
      }

      console.log(`‚úÖ [Session Sharing] Session ready for all branches with zalo_id: ${zaloId}`);

      // Start keep-alive for this session
      startKeepAliveForAccount(accountId);

      // Start WebSocket listener for this session
      startWebSocketListenerForAccount(accountId);

      // Start health monitoring for this session
      startHealthMonitorForAccount(accountId);

      console.log(`üéâ Account ${accountId} fully initialized and ready!`);
    }).catch((error) => {
      console.error(`‚ùå Login failed for account ${accountId}:`, error);
      updateSessionData(accountId, {
        loginInProgress: false,
        loginCompleted: false
      });
    });

    // Wait for QR callback to be invoked (with timeout)
    // The loginQR() method should call the callback within a few seconds
    const QR_CALLBACK_TIMEOUT = 5000; // 5 seconds
    await new Promise((resolve) => {
      const startTime = Date.now();
      const checkInterval = setInterval(() => {
        if (qrReceived || (Date.now() - startTime) > QR_CALLBACK_TIMEOUT) {
          clearInterval(checkInterval);
          resolve();
        }
      }, 100); // Check every 100ms
    });

    if (!qrReceived) {
      console.log(`‚ö†Ô∏è  QR callback not received within ${QR_CALLBACK_TIMEOUT}ms for account ${accountId}`);
      console.log(`   Attempting to read QR file manually...`);

      // Fallback: Try to read QR file if it exists
      // Try both qr_${accountId}.png and qr.png (library default)
      const qrPaths = [
        qrFilePath,
        path.join(__dirname, '..', 'qr.png'), // Library default
      ];

      try {
        let foundQr = false;
        for (const qrPath of qrPaths) {
          if (fs.existsSync(qrPath)) {
            console.log(`   Found QR file at: ${qrPath}`);
            const qrImageBuffer = fs.readFileSync(qrPath);
            const qrImageBase64 = qrImageBuffer.toString('base64');
            qrBase64 = `data:image/png;base64,${qrImageBase64}`;
            qrReceived = true;
            foundQr = true;
            console.log(`‚úÖ Successfully read QR from file for account ${accountId}`);

            // Call the callback if provided
            if (qrCallback && typeof qrCallback === 'function') {
              qrCallback(qrBase64);
            }
            break;
          }
        }

        if (!foundQr) {
          console.log(`   No QR file found in any of the expected paths`);
        }
      } catch (error) {
        console.error(`‚ùå Failed to read QR file for account ${accountId}:`, error.message);
      }
    }

    // Return the zaloClient (not API instance yet)
    // The API instance will be stored in sessions Map after successful login
    return zaloClient;

  } catch (error) {
    console.error(`‚ùå Initialize error for account ${accountId}:`, error);
    updateSessionData(accountId, {
      loginInProgress: false,
      loginCompleted: false
    });
    throw error;
  }
}

// ============================================================================
// SESSION MANAGEMENT
// ============================================================================

/**
 * Check if a specific account is ready
 */
function isAccountReady(accountId = null) {
  const targetId = accountId || activeAccountId;

  if (!targetId) {
    return false;
  }

  const data = getSessionData(targetId);
  const session = sessions.get(targetId);

  return data.loginCompleted && data.isInitialized && session !== null;
}

/**
 * Switch active account
 */
function switchAccount(accountId) {
  console.log(`üîÑ Switching to account ${accountId}...`);

  if (!sessions.has(accountId)) {
    throw new Error(`Account ${accountId} not found in sessions`);
  }

  const data = getSessionData(accountId);
  if (!data.loginCompleted || !data.isInitialized) {
    throw new Error(`Account ${accountId} is not ready`);
  }

  const oldActive = activeAccountId;
  activeAccountId = accountId;

  console.log(`‚úÖ Switched from account ${oldActive} to ${accountId}`);
  console.log(`   Active account is now: ${activeAccountId}`);

  return true;
}

/**
 * Get all active sessions
 */
function getAllSessions() {
  const sessionsList = [];

  for (const [accountId, session] of sessions.entries()) {
    const data = getSessionData(accountId);

    sessionsList.push({
      accountId: accountId,
      sessionId: getSessionId(accountId),
      isConnected: data.loginCompleted && data.isInitialized,
      isActive: accountId === activeAccountId
    });
  }

  return {
    sessions: sessionsList,
    activeAccountId: activeAccountId,
    total: sessionsList.length
  };
}

/**
 * Disconnect a specific account
 */
async function disconnectAccount(accountId) {
  console.log(`üîå Disconnecting account ${accountId}...`);

  if (!sessions.has(accountId)) {
    console.log(`   Account ${accountId} not found in sessions`);
    return false;
  }

  // Stop health monitor
  stopHealthMonitorForAccount(accountId);

  // Stop keep-alive
  const data = getSessionData(accountId);
  if (data.keepAliveInterval) {
    clearInterval(data.keepAliveInterval);
    updateSessionData(accountId, { keepAliveInterval: null });
  }

  // Stop WebSocket listener
  if (data.wsListener) {
    try {
      const session = sessions.get(accountId);
      if (session && session.listener && typeof session.listener.stopListening === 'function') {
        await session.listener.stopListening();
      }
    } catch (error) {
      console.error(`   Error stopping listener: ${error.message}`);
    }
    updateSessionData(accountId, { wsListener: null });
  }

  // Remove from sessions
  sessions.delete(accountId);
  sessionData.delete(accountId);

  // If this was active account, switch to another or clear
  if (activeAccountId === accountId) {
    const remainingSessions = Array.from(sessions.keys());
    if (remainingSessions.length > 0) {
      activeAccountId = remainingSessions[0];
      console.log(`   Switched active account to ${activeAccountId}`);
    } else {
      activeAccountId = null;
      console.log(`   No remaining sessions, cleared active account`);
    }
  }

  console.log(`‚úÖ Account ${accountId} disconnected`);
  console.log(`   Remaining sessions: ${sessions.size}`);

  return true;
}

/**
 * Get current Zalo client (for backward compatibility)
 */
function getZaloClient(accountId = null) {
  return getSession(accountId);
}

// ============================================================================
// KEEP-ALIVE
// ============================================================================

/**
 * Start keep-alive for a specific account
 */
function startKeepAliveForAccount(accountId) {
  const session = sessions.get(accountId);
  const data = getSessionData(accountId);

  if (!session || typeof session.keepAlive !== 'function') {
    console.log(`‚ö†Ô∏è  Cannot start keep-alive for account ${accountId}: No valid session`);
    return;
  }

  // Clear existing interval if any
  if (data.keepAliveInterval) {
    clearInterval(data.keepAliveInterval);
  }

  console.log(`üîÑ Starting keep-alive for account ${accountId} (interval: ${KEEP_ALIVE_INTERVAL}ms)`);

  const interval = setInterval(async () => {
    try {
      const currentSession = sessions.get(accountId);
      if (currentSession && typeof currentSession.keepAlive === 'function') {
        await currentSession.keepAlive();
        // Silent - don't log every keep-alive
      }
    } catch (error) {
      console.error(`‚ùå Keep-alive failed for account ${accountId}:`, error.message);
    }
  }, KEEP_ALIVE_INTERVAL);

  updateSessionData(accountId, { keepAliveInterval: interval });
  console.log(`‚úÖ Keep-alive started for account ${accountId}`);
}

/**
 * Stop keep-alive for all accounts
 */
function stopKeepAlive() {
  console.log('üõë Stopping keep-alive for all accounts...');

  for (const [accountId, data] of sessionData.entries()) {
    if (data.keepAliveInterval) {
      clearInterval(data.keepAliveInterval);
      console.log(`   Stopped keep-alive for account ${accountId}`);
    }
  }
}

// ============================================================================
// HEALTH MONITORING
// ============================================================================

/**
 * Start health monitoring for a specific account
 */
function startHealthMonitorForAccount(accountId) {
  if (healthMonitors.has(accountId)) {
    console.log(`‚ö†Ô∏è  Health monitor already exists for account ${accountId}`);
    return healthMonitors.get(accountId);
  }

  console.log(`üè• Starting health monitor for account ${accountId}...`);

  // Create health monitor with access to this service
  const zaloService = {
    getClient: () => getSession(accountId),
    stopListener: () => stopListenerForAccount(accountId),
    startListener: () => startWebSocketListenerForAccount(accountId)
  };

  const healthMonitor = new HealthMonitor(zaloService);
  healthMonitor.start();

  healthMonitors.set(accountId, healthMonitor);
  console.log(`‚úÖ Health monitor started for account ${accountId}`);

  return healthMonitor;
}

/**
 * Stop health monitor for a specific account
 */
function stopHealthMonitorForAccount(accountId) {
  const healthMonitor = healthMonitors.get(accountId);
  if (healthMonitor) {
    healthMonitor.stop();
    healthMonitors.delete(accountId);
    console.log(`üõë Health monitor stopped for account ${accountId}`);
  }
}

/**
 * Stop listener for a specific account
 */
async function stopListenerForAccount(accountId) {
  const session = sessions.get(accountId);
  const data = getSessionData(accountId);

  if (!session) {
    console.log(`‚ö†Ô∏è  No session found for account ${accountId}`);
    return;
  }

  if (data.wsListener && session.listener && typeof session.listener.stopListening === 'function') {
    console.log(`üõë Stopping listener for account ${accountId}...`);
    await session.listener.stopListening();
    updateSessionData(accountId, { wsListener: null });
    console.log(`‚úÖ Listener stopped for account ${accountId}`);
  }
}

/**
 * Get health status for a specific account
 */
function getHealthStatus(accountId) {
  const healthMonitor = healthMonitors.get(accountId);
  if (!healthMonitor) {
    return {
      error: 'No health monitor found for this account',
      accountId: accountId
    };
  }

  return {
    accountId: accountId,
    ...healthMonitor.getStatus()
  };
}

/**
 * Get health status for all accounts
 */
function getAllHealthStatus() {
  const statuses = [];
  for (const [accountId, healthMonitor] of healthMonitors.entries()) {
    statuses.push({
      accountId: accountId,
      ...healthMonitor.getStatus()
    });
  }
  return statuses;
}

// ============================================================================
// WEBSOCKET LISTENER
// ============================================================================

/**
 * Handle incoming message and forward to Laravel webhook
 */
async function handleIncomingMessage(accountId, event) {
  try {
    // Record incoming message activity for health monitoring
    const healthMonitor = healthMonitors.get(accountId);
    if (healthMonitor) {
      healthMonitor.recordIncomingMessage();
    }

    const laravelUrl = process.env.LARAVEL_URL || 'http://127.0.0.1:8000';
    const apiKey = process.env.API_SECRET_KEY;

    if (!apiKey) {
      console.warn('‚ö†Ô∏è  API_SECRET_KEY not set, cannot save message');
      return;
    }

    // Extract message data from event
    const recipientId = event.userId || event.groupId;
    const recipientType = event.groupId ? 'group' : 'user';

    // Fetch recipient info (name and avatar) from Zalo API
    let recipientName = null;
    let recipientAvatar = null;

    try {
      const session = getSession(accountId);
      if (session) {
        if (recipientType === 'group' && typeof session.getGroupInfo === 'function') {
          console.log(`üì• [zalo-service] Fetching group info for ${recipientId}...`);
          const groupInfo = await session.getGroupInfo(recipientId);
          if (groupInfo) {
            // Extract from gridInfoMap if available
            if (groupInfo.gridInfoMap && groupInfo.gridInfoMap[recipientId]) {
              const groupData = groupInfo.gridInfoMap[recipientId];
              recipientName = groupData.name || null;
              recipientAvatar = groupData.avt || groupData.fullAvt || null;
            } else {
              recipientName = groupInfo.name || null;
              recipientAvatar = groupInfo.avt || groupInfo.fullAvt || groupInfo.avatar || null;
            }
            console.log(`   ‚úÖ Group info fetched: ${recipientName}`);
          }
        } else if (recipientType === 'user' && typeof session.getUserInfo === 'function') {
          console.log(`üì• [zalo-service] Fetching user info for ${recipientId}...`);
          const userInfo = await session.getUserInfo(recipientId);
          if (userInfo) {
            // Extract from changed_profiles if available
            if (userInfo.changed_profiles && userInfo.changed_profiles[recipientId]) {
              const userData = userInfo.changed_profiles[recipientId];
              recipientName = userData.displayName || userData.zaloName || userData.name || null;
              recipientAvatar = userData.avatar || userData.avatarUrl || null;
            } else {
              recipientName = userInfo.displayName || userInfo.zaloName || userInfo.name || null;
              recipientAvatar = userInfo.avatar || userInfo.avatarUrl || null;
            }
            console.log(`   ‚úÖ User info fetched: ${recipientName}`);
          }
        }
      }
    } catch (fetchError) {
      console.warn(`‚ö†Ô∏è  [zalo-service] Failed to fetch recipient info:`, fetchError.message);
      // Continue without recipient info - it's not critical
    }

    // Ensure content is always a string (safely handle different types)
    let content = '';
    let contentObject = null;
    const rawContent = event.text || event.content || '';
    if (typeof rawContent === 'string') {
      content = rawContent;
    } else if (typeof rawContent === 'number') {
      content = String(rawContent);
    } else if (rawContent && typeof rawContent === 'object') {
      // Store object for content type detection
      contentObject = rawContent;
      // If it's an object or array, stringify it
      content = JSON.stringify(rawContent);
    }

    const messageId = event.messageId || event.id || null;
    const cliMsgId = event.cliMsgId || null;
    const attachment = event.attachment || null;
    const quote = event.quote || null;

    // Determine content type
    let contentType = 'text';
    let mediaUrl = null;
    let stickerData = null;
    let fileData = null;

    // üé® Check for sticker messages
    // Stickers come as content objects with sticker properties (id, stickerUrl, etc.)
    // üîß FIX: Also detect stickers WITHOUT URLs (received stickers might only have id, cateId, type)
    const isSticker = contentObject && (contentObject.stickerId || contentObject.id) && (contentObject.stickerUrl || contentObject.cateId !== undefined);

    if (isSticker) {
      contentType = 'sticker';
      const stickerId = contentObject.stickerId || contentObject.id;

      // üîß FIX: If sticker doesn't have URL, fetch it from Zalo API
      if (!contentObject.stickerUrl && !contentObject.stickerWebpUrl) {
        console.log(`üé® [zalo-service] Sticker received without URL, fetching details...`, {
          stickerId,
          cateId: contentObject.cateId,
          type: contentObject.type
        });

        try {
          // Fetch sticker details from Zalo API
          if (zalo && typeof zalo.getStickersDetail === 'function') {
            const stickerDetails = await zalo.getStickersDetail([stickerId]);

            if (stickerDetails && stickerDetails.length > 0) {
              const details = stickerDetails[0];
              console.log(`‚úÖ [zalo-service] Fetched sticker details:`, {
                id: details.id,
                hasStickerUrl: !!details.stickerUrl,
                hasWebpUrl: !!details.stickerWebpUrl
              });

              // Merge fetched details with existing data
              contentObject.stickerUrl = details.stickerUrl;
              contentObject.stickerWebpUrl = details.stickerWebpUrl;
              contentObject.stickerSpriteUrl = details.stickerSpriteUrl;
              contentObject.uri = details.uri || contentObject.uri;
              contentObject.text = details.text || contentObject.text || '';
            }
          }
        } catch (error) {
          console.error(`‚ùå [zalo-service] Failed to fetch sticker details:`, error.message);
          // Continue without URL - will be displayed as fallback in frontend
        }
      }

      mediaUrl = contentObject.stickerUrl || contentObject.stickerWebpUrl || contentObject.uri;
      stickerData = {
        id: stickerId,
        cateId: contentObject.cateId,
        type: contentObject.type,
        text: contentObject.text || '',
        uri: contentObject.uri,
        stickerUrl: contentObject.stickerUrl,
        stickerSpriteUrl: contentObject.stickerSpriteUrl,
        stickerWebpUrl: contentObject.stickerWebpUrl,
      };
      // Override content to be sticker text/emoji representation
      content = contentObject.text || '[Sticker]';
    }
    // üîß FIX: Check for image/file in content object (Zalo link cards)
    else if (contentObject && contentObject.href) {
      const href = contentObject.href;
      const title = contentObject.title || '';
      const params = contentObject.params || '';

      // Check if it's a Zalo CDN URL (images/files)
      if (href.match(/\.(jpg|jpeg|png|gif|webp|bmp)(\?|$)/i) || href.includes('.zdn.vn/') || href.includes('zalo-api')) {
        contentType = 'image';
        mediaUrl = href;
      }
      // Check for file by URL extension
      else if (href.match(/\.(pdf|doc|docx|xls|xlsx|ppt|pptx|zip|rar|txt)(\?|$)/i)) {
        contentType = 'file';
        mediaUrl = href;
        fileData = contentObject; // Store full file metadata
      }
      // üÜï Check for file by title extension (for URLs without extensions like dlfl.vn)
      else if (title && title.match(/\.(pdf|doc|docx|xls|xlsx|ppt|pptx|zip|rar|txt|7z|tar|gz)$/i)) {
        contentType = 'file';
        mediaUrl = href;
        fileData = contentObject; // Store full file metadata
        // Override content to show filename
        content = title;
      }
      // üÜï Check for file by params metadata
      else if (params && (params.includes('"fileExt"') || params.includes('"fileSize"') || params.includes('"fType"'))) {
        contentType = 'file';
        mediaUrl = href;
        fileData = contentObject; // Store full file metadata
        if (title) content = title;
      }
    }

    // Check attachment (original logic)
    if (attachment && contentType === 'text') {
      if (attachment.type === 'image' || attachment.url?.match(/\.(jpg|jpeg|png|gif|webp)$/i)) {
        contentType = 'image';
        mediaUrl = attachment.url;
      } else if (attachment.type === 'file' || attachment.url) {
        contentType = 'file';
        mediaUrl = attachment.url;
      } else if (attachment.type === 'sticker' || attachment.stickerId) {
        contentType = 'sticker';
        const stickerId = attachment.stickerId || attachment.id;

        // üîß FIX: If sticker attachment doesn't have URL, fetch it from Zalo API
        if (!attachment.stickerUrl && !attachment.stickerWebpUrl) {
          console.log(`üé® [zalo-service] Sticker attachment received without URL, fetching details...`, {
            stickerId,
            cateId: attachment.cateId,
            type: attachment.type
          });

          try {
            // Fetch sticker details from Zalo API
            if (zalo && typeof zalo.getStickersDetail === 'function') {
              const stickerDetails = await zalo.getStickersDetail([stickerId]);

              if (stickerDetails && stickerDetails.length > 0) {
                const details = stickerDetails[0];
                console.log(`‚úÖ [zalo-service] Fetched sticker attachment details:`, {
                  id: details.id,
                  hasStickerUrl: !!details.stickerUrl,
                  hasWebpUrl: !!details.stickerWebpUrl
                });

                // Merge fetched details with existing data
                attachment.stickerUrl = details.stickerUrl;
                attachment.stickerWebpUrl = details.stickerWebpUrl;
                attachment.stickerSpriteUrl = details.stickerSpriteUrl;
                attachment.uri = details.uri || attachment.uri;
                attachment.text = details.text || attachment.text || '';
              }
            }
          } catch (error) {
            console.error(`‚ùå [zalo-service] Failed to fetch sticker attachment details:`, error.message);
            // Continue without URL - will be displayed as fallback in frontend
          }
        }

        mediaUrl = attachment.stickerUrl || attachment.stickerWebpUrl || attachment.url;
        stickerData = {
          id: stickerId,
          cateId: attachment.cateId,
          type: attachment.type,
          text: attachment.text || '',
          uri: attachment.uri,
          stickerUrl: attachment.stickerUrl,
          stickerSpriteUrl: attachment.stickerSpriteUrl,
          stickerWebpUrl: attachment.stickerWebpUrl,
        };
        content = attachment.text || '[Sticker]';
      }
    }

    // MULTI-SESSION: Send account_id to Laravel webhook
    console.log(`üì§ [zalo-service] Forwarding message to Laravel webhook...`, {
      account_id: accountId,
      recipient_id: recipientId,
      recipient_type: recipientType,
      is_self: event.isSelf || false,
      message_id: messageId,
    });

    // Call Laravel API to save message with ALL IDs
    // Retry mechanism for reliability
    const maxRetries = 3;
    let retries = 0;
    let response = null;
    let lastError = null;

    while (retries < maxRetries) {
      try {
        response = await fetch(`${laravelUrl}/api/zalo/messages/receive`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-API-Key': apiKey,
            'Accept': 'application/json'
          },
          body: JSON.stringify({
            account_id: accountId, // MULTI-SESSION: Use account_id instead of zalo_id
            recipient_id: recipientId,
            recipient_type: recipientType,
            recipient_name: recipientName, // Recipient name (friend or group)
            recipient_avatar: recipientAvatar, // Recipient avatar URL
            message_id: messageId,
            cli_msg_id: cliMsgId,
            global_msg_id: event.globalMsgId || messageId,
            real_msg_id: event.realMsgId || messageId,
            // Send all IDs for accurate finding
            all_message_ids: event.allMessageIds || {
              msgId: messageId,
              cliMsgId: cliMsgId,
              realMsgId: event.realMsgId || messageId,
              globalMsgId: event.globalMsgId || messageId,
            },
            sender_id: event.senderId || null, // Sender Zalo user ID (for group messages)
            sender_name: event.senderName || null, // Sender display name (for group messages)
            content: content,
            content_type: contentType,
            media_url: mediaUrl,
            sticker_data: stickerData, // Sticker metadata (id, stickerUrl, etc.)
            file_data: fileData, // File metadata (title, href, params, etc.)
            quote: quote,
            is_self: event.isSelf || false, // CRITICAL: Indicates if message is from same account (other device)
            // üîß FIX: Don't send timestamp - let Laravel use its own now() timestamp
            // Zalo's timestamp can be off by 1-2 minutes due to server processing delays
            // sent_at: event.timestamp || new Date().toISOString()
          })
        });

        if (response.ok) {
          const result = await response.json();
          console.log(`‚úÖ [zalo-service] Message saved successfully`, {
            account_id: accountId,
            db_message_id: result.data?.id,
            zalo_message_id: messageId,
          });
          break; // Success, exit retry loop
        }

        // If not OK, retry
        retries++;
        if (retries < maxRetries) {
          const delay = 1000 * retries; // Exponential backoff: 1s, 2s, 3s
          console.log(`‚ö†Ô∏è  [zalo-service] Save message failed, retrying in ${delay}ms (attempt ${retries}/${maxRetries})...`);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      } catch (error) {
        lastError = error;
        retries++;
        if (retries < maxRetries) {
          const delay = 1000 * retries;
          console.log(`‚ö†Ô∏è  [zalo-service] Save message error, retrying in ${delay}ms (attempt ${retries}/${maxRetries})...`);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }

    // Log final error if all retries failed
    if (retries >= maxRetries) {
      if (lastError) {
        console.error(`‚ùå [zalo-service] Failed to save message after ${maxRetries} retries:`, lastError.message);
      } else if (response) {
        const errorText = await response.text();
        console.error(`‚ùå [zalo-service] Failed to save message after ${maxRetries} retries. Response:`, errorText);
      }
    }

  } catch (error) {
    console.error(`‚ùå [zalo-service] Error in handleIncomingMessage:`, error.message);
    if (error.stack) {
      console.error('   Stack:', error.stack);
    }
  }
}

/**
 * MULTI-SESSION: Handle incoming reaction from WebSocket listener
 * Forward reaction to Laravel webhook with account_id
 */
async function handleIncomingReaction(accountId, event) {
  try {
    const laravelUrl = process.env.LARAVEL_URL || 'http://127.0.0.1:8000';
    const apiKey = process.env.API_SECRET_KEY;

    if (!apiKey) {
      console.warn('‚ö†Ô∏è  API_SECRET_KEY not set, cannot save reaction');
      return;
    }

    const payload = {
      account_id: accountId, // MULTI-SESSION: Use account_id instead of zalo_id
      message_id: event.messageId,
      cli_msg_id: event.cliMsgId,
      recipient_id: event.userId || event.groupId,
      recipient_type: event.groupId ? 'group' : 'user',
      user_id: event.userIdFrom,
      reaction_icon: event.reactionIcon,
      reaction_type: event.reactionType,
      reaction_source: event.reactionSource,
      reaction_data: event.reactionData,
      reacted_at: event.timestamp
    };

    console.log('üì§ [zalo-service] Sending reaction to Laravel:', {
      account_id: payload.account_id,
      message_id: payload.message_id,
      cli_msg_id: payload.cli_msg_id,
      recipient_id: payload.recipient_id,
      recipient_type: payload.recipient_type,
      user_id: payload.user_id,
      reaction_icon: payload.reaction_icon,
    });

    // Call Laravel API to save reaction with retry mechanism
    // Retry if message not found (might be race condition - message not saved yet)
    const maxRetries = 3;
    let retries = 0;
    let response = null;
    let lastError = null;

    while (retries < maxRetries) {
      try {
        response = await fetch(`${laravelUrl}/api/zalo/messages/receive-reaction`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-API-Key': apiKey,
            'Accept': 'application/json'
          },
          body: JSON.stringify(payload)
        });

        if (response.ok) {
          const result = await response.json();
          console.log(`‚úÖ [zalo-service] Reaction saved successfully`, {
            account_id: accountId,
            message_id: payload.message_id,
            reaction_icon: payload.reaction_icon,
          });
          break; // Success, exit retry loop
        }

        // If 404 (message not found), retry after delay
        // This handles race condition where reaction arrives before message is saved
        if (response.status === 404) {
          const errorData = await response.json().catch(() => ({}));
          if (errorData.message && errorData.message.includes('Message not found')) {
            retries++;
            if (retries < maxRetries) {
              const delay = 1000 * retries; // Exponential backoff: 1s, 2s, 3s
              console.log(`‚ö†Ô∏è  [zalo-service] Message not found for reaction, retrying in ${delay}ms (attempt ${retries}/${maxRetries})...`);
              console.log(`   Searching for: message_id=${payload.message_id}, cli_msg_id=${payload.cli_msg_id}`);
              await new Promise(resolve => setTimeout(resolve, delay));
              continue; // Retry
            }
          }
        }

        // For other errors, don't retry
        break;

      } catch (error) {
        lastError = error;
        retries++;
        if (retries < maxRetries) {
          const delay = 1000 * retries;
          console.log(`‚ö†Ô∏è  [zalo-service] Save reaction error, retrying in ${delay}ms (attempt ${retries}/${maxRetries})...`);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }

    // Log final error if all retries failed
    if (retries >= maxRetries) {
      if (lastError) {
        console.error(`‚ùå [zalo-service] Failed to save reaction after ${maxRetries} retries:`, lastError.message);
      } else if (response && !response.ok) {
        const errorText = await response.text();
        console.error(`‚ùå [zalo-service] Failed to save reaction after ${maxRetries} retries. Response:`, errorText);
      }
    }

  } catch (error) {
    console.error(`‚ùå [zalo-service] Error in handleIncomingReaction:`, error.message);
    if (error.stack) {
      console.error('   Stack:', error.stack);
    }
  }
}

/**
 * Start WebSocket listener for a specific account
 */
async function startWebSocketListenerForAccount(accountId) {
  const session = sessions.get(accountId);
  const data = getSessionData(accountId);

  if (!session) {
    console.log(`‚ö†Ô∏è  Cannot start listener for account ${accountId}: No session`);
    return;
  }

  console.log(`üéß Starting WebSocket listener for account ${accountId}...`);

  try {
    if (!session.listener || typeof session.listener.start !== 'function') {
      console.log(`‚ö†Ô∏è  No listener available for account ${accountId}`);
      return;
    }

    const listener = session.listener;

    // CRITICAL: Register event handlers BEFORE starting listener
    console.log(`üéß [Account ${accountId}] Registering event handlers...`);

    // Listen for messages
    listener.on('message', async (message) => {
      console.log(`üîî [Account ${accountId}] *** MESSAGE EVENT RECEIVED ***`, {
        type: message?.type,
        threadId: message?.threadId,
        isSelf: message?.isSelf,
      });

      // MULTI-SESSION: Parse message and forward to Laravel
      console.log('üì® [WebSocket] Received Zalo message:', {
        account_id: accountId,
        type: message.type,
        threadId: message.threadId,
        isSelf: message.isSelf,
        hasData: !!message.data,
        msgId: message.data?.msgId,
      });

      try {
        // Parse message similar to single-session version
        const isGroup = message.type === 1; // ThreadType.Group
        const messageData = message.data;

        if (!messageData) {
          console.warn('‚ö†Ô∏è  No message data');
          return;
        }

        // Extract text content
        let text = '';
        if (messageData.content) {
          text = messageData.content;
        } else if (messageData.msg) {
          text = messageData.msg;
        }

        // Extract attachment if exists
        let attachment = null;
        if (messageData.href) {
          attachment = {
            type: 'image',
            url: messageData.href
          };
        }

        // Extract quote data if exists
        let quoteData = null;
        if (messageData.quote) {
          // Convert BigNumber IDs to strings
          const ownerIdStr = messageData.quote.ownerId ? String(messageData.quote.ownerId) : null;
          const cliMsgIdStr = messageData.quote.cliMsgId ? String(messageData.quote.cliMsgId) : null;
          const globalMsgIdStr = messageData.quote.globalMsgId ? String(messageData.quote.globalMsgId) : null;

          quoteData = {
            ownerId: ownerIdStr,
            uidFrom: ownerIdStr,
            cliMsgId: cliMsgIdStr,
            globalMsgId: globalMsgIdStr,
            msgId: globalMsgIdStr,
            cliMsgType: messageData.quote.msgType || messageData.quote.cliMsgType,
            msgType: messageData.quote.msgType || messageData.quote.cliMsgType,
            msg: messageData.quote.content || messageData.quote.msg || '',
            content: messageData.quote.content || messageData.quote.msg || '',
          };
        }

        // Convert message IDs to strings
        const msgId = messageData.msgId?.toString() || null;
        const realMsgId = messageData.realMsgId?.toString() || null;
        const cliMsgId = messageData.cliMsgId?.toString() || null;
        const globalMsgId = messageData.globalMsgId?.toString() || msgId || realMsgId;
        const primaryMessageId = msgId || realMsgId || cliMsgId || null;

        // Extract sender information (important for group messages)
        const senderId = messageData.uidFrom ? String(messageData.uidFrom) : null;
        const senderName = messageData.dName || messageData.displayName || null;

        const event = {
          type: 'message',
          userId: isGroup ? null : message.threadId,
          groupId: isGroup ? message.threadId : null,
          text: text,
          content: text,
          messageId: primaryMessageId,
          id: primaryMessageId,
          cliMsgId: cliMsgId,
          globalMsgId: globalMsgId,
          realMsgId: realMsgId,
          allMessageIds: {
            msgId: msgId,
            cliMsgId: cliMsgId,
            realMsgId: realMsgId,
            globalMsgId: globalMsgId,
          },
          senderId: senderId,
          senderName: senderName,
          attachment: attachment,
          quote: quoteData,
          isSelf: message.isSelf,
          timestamp: messageData.ts ? new Date(parseInt(messageData.ts)).toISOString() : new Date().toISOString()
        };

        // Forward to Laravel webhook
        await handleIncomingMessage(accountId, event);

      } catch (parseError) {
        console.error(`‚ùå [Account ${accountId}] Error parsing message:`, parseError);
      }
    });

    // Listen for reactions
    listener.on('reaction', (reaction) => {
      console.log(`üòä [Account ${accountId}] *** REACTION EVENT RECEIVED ***`, {
        hasData: !!reaction,
        dataKeys: reaction?.data ? Object.keys(reaction.data) : null,
        timestamp: new Date().toISOString(),
      });

      const reactionIcon = reaction.data?.content?.rIcon || reaction.data?.rIcon;

      // Extract message ID - reaction.data.msgId is the reaction's own ID, NOT the message ID!
      // The actual message being reacted to is in content.rMsg[0].gMsgID (globalMsgId) or cMsgID (cliMsgId)
      let msgId = null;
      let cliMsgId = null;

      // PRIORITY: Extract from content.rMsg[0] - this contains the actual message IDs
      if (reaction.data?.content?.rMsg && Array.isArray(reaction.data.content.rMsg) && reaction.data.content.rMsg.length > 0) {
        const rMsg = reaction.data.content.rMsg[0];

        // gMsgID is the global message ID (msgId from Zalo server) - THIS IS THE PRIMARY ID
        if (rMsg.gMsgID) {
          msgId = rMsg.gMsgID.toString();
        }
        // cMsgID is the client message ID (cliMsgId)
        if (rMsg.cMsgID) {
          cliMsgId = rMsg.cMsgID.toString();
        }

        // Fallback: Try other field names (case variations)
        if (!msgId && rMsg.gMsgId) {
          msgId = rMsg.gMsgId.toString();
        }
        if (!msgId && rMsg.msgId) {
          msgId = rMsg.msgId.toString();
        }
        if (!msgId && rMsg.cMsg) {
          msgId = rMsg.cMsg.toString();
        }
        if (!cliMsgId && rMsg.cMsgId) {
          cliMsgId = rMsg.cMsgId.toString();
        }
        if (!cliMsgId && rMsg.cliMsgId) {
          cliMsgId = rMsg.cliMsgId.toString();
        }
      }

      // Fallback: If still no IDs found, try from reaction.data (but these are usually reaction IDs, not message IDs)
      if (!msgId) {
        msgId = reaction.data?.msgId?.toString() || null;
      }
      if (!cliMsgId) {
        cliMsgId = reaction.data?.cliMsgId?.toString() || null;
      }

      const threadId = reaction.threadId?.toString();

      console.log(`üòä [Account ${accountId}] Received Zalo reaction:`, {
        msgId: msgId,
        cliMsgId: cliMsgId,
        uidFrom: reaction.data?.uidFrom?.toString(),
        reactionIcon: reactionIcon,
        threadId: threadId,
        isGroup: reaction.isGroup,
        timestamp: new Date().toISOString(),
        rawData: JSON.stringify(reaction.data).substring(0, 500), // Log more data for debugging
        hasRMsg: !!(reaction.data?.content?.rMsg),
        rMsgLength: reaction.data?.content?.rMsg?.length || 0,
        rMsgData: reaction.data?.content?.rMsg?.[0] || null, // Log rMsg[0] for debugging
      });

      // Handle reaction - save to Laravel
      handleIncomingReaction(accountId, {
        type: 'reaction',
        userId: reaction.isGroup ? null : threadId,
        groupId: reaction.isGroup ? threadId : null,
        messageId: msgId,
        cliMsgId: cliMsgId,
        userIdFrom: reaction.data?.uidFrom?.toString(),
        reactionIcon: reactionIcon, // Use the extracted reactionIcon
        reactionType: reaction.data?.content?.rType || reaction.data?.rType || 0,
        reactionSource: reaction.data?.content?.source || reaction.data?.source || 0,
        reactionData: reaction.data,
        timestamp: reaction.data?.ts ? new Date(parseInt(reaction.data.ts)).toISOString() : new Date().toISOString()
      }).catch(error => {
        console.error(`‚ùå [Account ${accountId}] Failed to handle incoming reaction:`, error.message);
        if (error.stack) {
          console.error('   Stack:', error.stack);
        }
      });
    });

    // Listen for connection events
    listener.on('connected', () => {
      console.log(`‚úÖ [Account ${accountId}] WebSocket connected`);
    });

    listener.on('disconnected', (reason) => {
      console.log(`‚ö†Ô∏è  [Account ${accountId}] WebSocket disconnected:`, reason);
    });

    listener.on('closed', (reason) => {
      console.log(`‚ö†Ô∏è  [Account ${accountId}] WebSocket closed:`, reason);
    });

    listener.on('error', (error) => {
      const errorMessage = error?.message || String(error);
      if (!errorMessage.includes('closed before the connection was established') &&
          !errorMessage.includes('WebSocket was closed')) {
        console.error(`‚ùå [Account ${accountId}] WebSocket error:`, errorMessage);
      }
    });

    // Start the listener (this maintains WebSocket connection)
    console.log(`üéß [Account ${accountId}] Starting listener.start()...`);
    listener.start({ retryOnClose: true });

    updateSessionData(accountId, { wsListener: true });
    console.log(`‚úÖ WebSocket listener started for account ${accountId}`);

  } catch (error) {
    console.error(`‚ùå Failed to start listener for account ${accountId}:`, error);
  }
}

/**
 * Stop all WebSocket listeners
 */
async function stopWebSocketListener() {
  console.log('üõë Stopping WebSocket listeners for all accounts...');

  for (const [accountId, session] of sessions.entries()) {
    try {
      if (session.listener && typeof session.listener.stopListening === 'function') {
        await session.listener.stopListening();
        console.log(`   Stopped listener for account ${accountId}`);
      }
    } catch (error) {
      console.error(`   Error stopping listener for account ${accountId}:`, error.message);
    }
  }
}

// ============================================================================
// CREDENTIALS MANAGEMENT
// ============================================================================

/**
 * Save credentials for a specific account
 */
async function saveCredentialsForAccount(accountId, cookie) {
  console.log(`üíæ Saving credentials for account ${accountId}...`);

  // Save to sessions directory
  ensureSessionsDir();
  const sessionFile = path.join(getSessionsDir(), `${getSessionId(accountId)}.json`);

  try {
    const credentialsData = {
      accountId: accountId,
      cookie: cookie,
      imei: process.env.ZALO_IMEI || '',
      userAgent: process.env.ZALO_USER_AGENT || '',
      savedAt: new Date().toISOString()
    };

    fs.writeFileSync(sessionFile, JSON.stringify(credentialsData, null, 2));
    console.log(`   ‚úÖ Credentials saved to: ${sessionFile}`);
  } catch (error) {
    console.error(`   ‚ùå Failed to save credentials: ${error.message}`);
  }
}

// ============================================================================
// EXPORTS
// ============================================================================

module.exports = {
  // Initialization
  initializeZalo,

  // Session management
  isAccountReady,
  isZaloReady: () => isAccountReady(), // Backward compatibility
  switchAccount,
  getAllSessions,
  disconnectAccount,
  getZaloClient,
  getSession,

  // Multi-session specific
  sessions,
  sessionData,
  accountToZaloId, // Session sharing: accountId -> zaloId mapping
  getActiveAccountId: () => activeAccountId,
  setActiveAccountId: (id) => { activeAccountId = id; },

  // Keep-alive
  stopKeepAlive,

  // WebSocket
  stopWebSocketListener,

  // Health monitoring
  getHealthStatus,
  getAllHealthStatus,
  healthMonitors,
};
